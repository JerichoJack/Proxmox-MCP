{
  "nodes": [
    {
      "parameters": {
        "endpointUrl": "http://192.168.4.14:8888/mcp",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [
        2000,
        -832
      ],
      "id": "8ccf5550-b47b-4d23-8611-97179f46b1ff",
      "name": "MCP Tool"
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "sendAndWait",
        "guildId": {
          "__rl": true,
          "value": "329079420360982530",
          "mode": "list",
          "cachedResultName": "Jericho",
          "cachedResultUrl": "https://discord.com/channels/329079420360982530"
        },
        "channelId": "={{ $('Pull User Request').item.json.channelId || '1346909607854870610' }}",
        "message": "=🚨 **Action Requires Approval**\n\n**Target Node:** {{ $json.target_node }}\n**Action Requested:** {{ $json.commands_requested || \"Monitoring operation\" }}\n**MCP Tools:** {{ ($json.mcp_tools_used || []).join(', ') }}\n**Priority:** {{ $json.details?.priority || \"normal\" }}\n\n**Details:** {{ $json.combinedMessage }}\n\n**Estimated Impact:** {{ $json.details?.estimated_downtime || \"Low\" }}\n\nReply **approve** or **deny**",
        "approvalOptions": {
          "values": {
            "approvalType": "double"
          }
        },
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        3504,
        -1104
      ],
      "id": "95d67568-8259-4817-a757-5e466e54405c",
      "name": "Send AND Wait",
      "webhookId": "6723d109-35dd-466f-80d7-5c3971998a52",
      "credentials": {
        "discordBotApi": {
          "id": "oXOUwkFdAwpbp9ss",
          "name": "Discord Bot account"
        }
      },
      "notes": "👤 **User Approval Gateway**\n\n**Purpose:** Request user approval for potentially disruptive actions\n**Enhanced Display:**\n- Target node and action details\n- MCP tools that will be used\n- Priority level and estimated impact\n- Estimated downtime information\n\n**Actions Requiring Approval:**\n- Node reboots or maintenance mode\n- VM/LXC migrations or major changes\n- Storage operations, backup deletion\n- Configuration modifications\n\n**User Response:** approve/deny"
    },
    {
      "parameters": {
        "channelId": "={{ $('Pull User Request').item.json.channelId }}",
        "content": "={{ $json.final_message }}\n{{ $json.combinedMessage }}\n{{ $json.mcp_tools_used }}",
        "botCustomization": true,
        "botActivity": "and Waiting...",
        "botActivityType": 3,
        "botStatus": "idle"
      },
      "type": "@jjuanrivvera99/n8n-nodes-discord.discord",
      "typeVersion": 1,
      "position": [
        3504,
        -736
      ],
      "id": "09ac3209-8dc3-44e3-8415-838ce8d10e02",
      "name": "Send Reply",
      "credentials": {
        "discordApi": {
          "id": "zO7e3OjzgaUpNsfY",
          "name": "Discord App account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const results = $items().map(item => {\n    console.log('Structure Output - Processing item:', JSON.stringify(item, null, 2));\nconst aiAgentOutput = $input.first().json.output;\n    try {\n        let aiAgentOutput;\n        \n        // The AI Agent with Structured Output Parser returns data directly in the json object\n        // Check if data is already parsed (from Structured Output Parser)\n        if (item.json.tool_name && item.json.mcp_raw_response) {\n            // Data is already properly structured\n            aiAgentOutput = item.json;\n            console.log('AI Agent - Data already structured:', aiAgentOutput);\n        }\n        // Check for 'output' field (text response that needs parsing)\n        else if (item.json.output) {\n            const textContent = item.json.output;\n            console.log('AI Agent output field (text):', textContent);\n            \n            try {\n                // Try to parse JSON from text content\n                const jsonMatch = textContent.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n                const jsonString = jsonMatch ? jsonMatch[1].trim() : textContent.trim();\n                aiAgentOutput = JSON.parse(jsonString);\n            } catch (parseError) {\n                console.log('JSON parse error, attempting to fix:', parseError.message);\n                console.log('Failed text:', textContent.substring(0, 500));\n                \n                // Remove code blocks if present\n                let cleanText = textContent.replace(/```(?:json)?\\s*|```/g, '').trim();\n                \n                // Replace escaped newlines with actual spaces for better parsing\n                cleanText = cleanText.replace(/\\\\n/g, ' ');\n                \n                // Remove extra whitespace\n                cleanText = cleanText.replace(/\\s+/g, ' ');\n                \n                // Fix common AI Agent issue: stray ] after mcp_raw_response closes\n                // Pattern: }}}] followed by comma and next field (should be }}}, )\n                cleanText = cleanText.replace(/(\\}\\}\\})\\s*\\]\\s*,\\s*/g, '$1, ');\n                console.log('Removed stray array brackets after mcp_raw_response');\n                \n                // Fix common AI Agent issue: duplicate node data after mcp_raw_response\n                // Find where the standard fields end and truncate any extra data\n                const standardFieldsPattern = /(\"needs_approval\"\\s*:\\s*(?:true|false)\\s*,\\s*\"issue_detected\"\\s*:\\s*(?:true|false)\\s*,\\s*\"applied_fix\"\\s*:\\s*(?:true|false))\\s*,\\s*\"[A-Z]/;\n                const match = cleanText.match(standardFieldsPattern);\n                if (match) {\n                    // Found extra data after standard fields - truncate it\n                    const truncateIndex = match.index + match[1].length;\n                    cleanText = cleanText.substring(0, truncateIndex) + '}';\n                    console.log('Truncated duplicate data after standard fields');\n                }\n                \n                console.log('Cleaned text:', cleanText.substring(0, 500));\n                \n                // The AI Agent outputs incomplete JSON - missing closing brace\n                // Count braces to see if we need to close the JSON\n                const openBraces = (cleanText.match(/\\{/g) || []).length;\n                const closeBraces = (cleanText.match(/\\}/g) || []).length;\n                console.log(`Brace count - open: ${openBraces}, close: ${closeBraces}`);\n                \n                if (openBraces > closeBraces) {\n                    const missingBraces = openBraces - closeBraces;\n                    cleanText += '}'.repeat(missingBraces);\n                    console.log(`Added ${missingBraces} closing brace(s)`);\n                }\n                \n                console.log('Attempting to parse fixed JSON');\n                try {\n                    aiAgentOutput = JSON.parse(cleanText);\n                    console.log('Successfully parsed after cleaning and fixing');\n                } catch (secondError) {\n                    console.error('Still unable to parse:', secondError.message);\n                    console.log('Attempting manual extraction...');\n                    \n                    // Manual extraction as last resort\n                    const toolNameMatch = cleanText.match(/\"tool_name\"\\s*:\\s*\"([^\"]+)\"/);\n                    const targetNodeMatch = cleanText.match(/\"target_node\"\\s*:\\s*\"([^\"]+)\"/);\n                    const mcpToolsMatch = cleanText.match(/\"mcp_tools_used\"\\s*:\\s*\\[([^\\]]+)\\]/);\n                    const needsApprovalMatch = cleanText.match(/\"needs_approval\"\\s*:\\s*(true|false)/);\n                    const issueDetectedMatch = cleanText.match(/\"issue_detected\"\\s*:\\s*(true|false)/);\n                    const appliedFixMatch = cleanText.match(/\"applied_fix\"\\s*:\\s*(true|false)/);\n                    \n                    // Extract mcp_raw_response - find the entire nested object\n                    let mcpRawResponse = null;\n                    const mcpStart = cleanText.indexOf('\"mcp_raw_response\"');\n                    if (mcpStart !== -1) {\n                        const colonIndex = cleanText.indexOf(':', mcpStart);\n                        let braceCount = 0;\n                        let startIndex = -1;\n                        let endIndex = -1;\n                        \n                        for (let i = colonIndex; i < cleanText.length; i++) {\n                            if (cleanText[i] === '{') {\n                                if (startIndex === -1) startIndex = i;\n                                braceCount++;\n                            } else if (cleanText[i] === '}') {\n                                braceCount--;\n                                if (braceCount === 0) {\n                                    endIndex = i + 1;\n                                    break;\n                                }\n                            }\n                        }\n                        \n                        if (startIndex !== -1 && endIndex !== -1) {\n                            const mcpString = cleanText.substring(startIndex, endIndex);\n                            try {\n                                mcpRawResponse = JSON.parse(mcpString);\n                                console.log('Successfully extracted mcp_raw_response');\n                            } catch (e) {\n                                console.error('Failed to parse extracted mcp_raw_response:', e.message);\n                            }\n                        }\n                    }\n                    \n                    if (toolNameMatch && mcpRawResponse) {\n                        aiAgentOutput = {\n                            tool_name: toolNameMatch[1],\n                            target_node: targetNodeMatch ? targetNodeMatch[1] : 'all',\n                            mcp_tools_used: mcpToolsMatch ? JSON.parse('[' + mcpToolsMatch[1] + ']') : [],\n                            mcp_raw_response: mcpRawResponse,\n                            needs_approval: needsApprovalMatch ? needsApprovalMatch[1] === 'true' : false,\n                            issue_detected: issueDetectedMatch ? issueDetectedMatch[1] === 'true' : false,\n                            applied_fix: appliedFixMatch ? appliedFixMatch[1] === 'true' : false\n                        };\n                        console.log('Manually reconstructed JSON');\n                    } else {\n                        throw secondError;\n                    }\n                }\n            }\n        }\n        // Fallback - try to use item.json directly\n        else {\n            aiAgentOutput = item.json;\n        }\n        \n        console.log('Parsed AI Agent Output:', JSON.stringify(aiAgentOutput, null, 2));\n        \n        // Extract metadata from AI response\n        const toolName = aiAgentOutput.tool_name || 'unknown';\n        const targetNode = aiAgentOutput.target_node || 'all';\n        const mcpToolsUsed = aiAgentOutput.mcp_tools_used || [];\n        const needsApproval = aiAgentOutput.needs_approval || false;\n        const issueDetected = aiAgentOutput.issue_detected || false;\n        const appliedFix = aiAgentOutput.applied_fix || false;\n        \n        // Parse MCP raw response\n        let mcpRaw = aiAgentOutput.mcp_raw_response || {};\n        console.log('Initial mcp_raw_response:', JSON.stringify(mcpRaw, null, 2));\n        \n        if (typeof mcpRaw === 'string') {\n            mcpRaw = JSON.parse(mcpRaw);\n        }\n        \n        // Extract actual response data from nested Tool structure\n        // The structure is: Tool.response[0].text which contains the actual node data\n        if (mcpRaw.Tool && mcpRaw.Tool.response && Array.isArray(mcpRaw.Tool.response)) {\n            console.log('Extracting from Tool.response array');\n            if (mcpRaw.Tool.response.length > 0 && mcpRaw.Tool.response[0].text) {\n                console.log('Found text field in response[0]');\n                mcpRaw = mcpRaw.Tool.response[0].text;\n            } else {\n                mcpRaw = mcpRaw.Tool.response;\n            }\n        }\n        \n        console.log('Processed mcp_raw_response:', JSON.stringify(mcpRaw, null, 2));\n        \n        // === FORMAT OUTPUT BASED ON MCP DATA ===\n        let final_message = '';\n        let monitoringResults = {};\n        let queryType = 'generic';\n        \n        // GET NODE STATUS - Enhanced formatting for node status display\n        if (toolName === 'get_node_status') {\n            let nodes = [];\n            \n            // mcpRaw has already been processed and contains the actual node data\n            // Check if it's a direct array\n            if (Array.isArray(mcpRaw)) {\n                console.log('Using direct array format');\n                nodes = mcpRaw.map(node => ({\n                    ...node,\n                    // Use the name from the node data or fall back to host\n                    name: node.name || node.host\n                }));\n            }\n            // Handle object with node names as keys (most common format from MCP server)\n            else if (typeof mcpRaw === 'object' && !Array.isArray(mcpRaw)) {\n                console.log('Using object format with node names as keys');\n                nodes = Object.entries(mcpRaw).map(([name, data]) => ({ \n                    name: name.replace(/^(PVE|PBS)-/, ''), \n                    ...data \n                }));\n            }\n            \n            console.log('Processed nodes:', JSON.stringify(nodes, null, 2));\n            \n            if (nodes.length > 0) {\n                monitoringResults = {\n                    nodes_online: nodes.filter(node => node.status === 'online').length,\n                    nodes_total: nodes.length\n                };\n                queryType = 'node_status';\n                \n                // Check if all nodes are online\n                const allOnline = nodes.every(node => node.status === 'online');\n                const statusHeader = allOnline ? '✅ All Systems Operational' : '⚠️ Some Systems Offline';\n                \n                // Build the header\n                final_message = `${statusHeader}\\n🔧 GET NODE STATUS : ${targetNode.toUpperCase()}\\n\\n`;\n                \n                // Format each node\n                nodes.forEach((nodeData) => {\n                    const statusIcon = nodeData.status === 'online' ? \"🟢\" : \"🔴\";\n                    \n                    final_message += `${nodeData.name}: ${statusIcon}\\n`;\n                    final_message += `Type: ${nodeData.type}\\n`;\n                    final_message += `IP: ${nodeData.host}\\n\\n`;\n                });\n            } else {\n                final_message = `🔧 **GET NODE STATUS**\\n\\nNo node data available.`;\n            }\n        }\n        // NODE HEALTH CHECK\n        else if (toolName === 'check_node_health' && mcpRaw.connectivity_test) {\n            const ct = mcpRaw.connectivity_test;\n            monitoringResults = {\n                nodes_online: ct.nodes_healthy || 0,\n                nodes_total: ct.nodes_checked || 0\n            };\n            queryType = 'health_check';\n            \n            const statusIcon = (ct.nodes_healthy === ct.nodes_checked) ? \"🟢\" : \"🔴\";\n            final_message = `🖥️ **Proxmox Infrastructure Status**\\n\\n${statusIcon} **Nodes:** ${ct.nodes_healthy}/${ct.nodes_checked} Online\\n\\n`;\n            \n            if (ct.detailed_connectivity) {\n                final_message += `📊 **Node Details:**\\n`;\n                ct.detailed_connectivity.forEach(n => {\n                    const icon = n.success ? \"🟢\" : \"🔴\";\n                    final_message += `${icon} **${n.node_name}** (${n.type}) - ${n.host} - v${n.version}\\n`;\n                });\n            }\n            \n            const health = mcpRaw.overall_health || 'unknown';\n            final_message += `\\n✅ **Overall Health:** ${health.toUpperCase()}`;\n        }\n        // VM LIST - when mcp_raw_response is already an array (not nested)\n        else if (Array.isArray(aiAgentOutput.mcp_raw_response)) {\n            const vms = aiAgentOutput.mcp_raw_response;\n            if (vms.some(v => v.vmid)) {\n                monitoringResults = {\n                    total_vms: vms.length,\n                    vms_running: vms.filter(v => v.status === 'running').length\n                };\n                queryType = 'vm_list';\n                \n                final_message = `💻 **Virtual Machines on ${targetNode}**\\n\\n� **Summary:** ${vms.length} VMs (${monitoringResults.vms_running} running)\\n\\n`;\n                \n                vms.forEach(vm => {\n                    const icon = vm.status === 'running' ? \"🟢\" : \"🔴\";\n                    final_message += `${icon} **${vm.name || 'VM-' + vm.vmid}** (ID: ${vm.vmid})\\n`;\n                    if (vm.status === 'running') {\n                        const memGB = ((vm.mem || 0) / 1024 ** 3).toFixed(1);\n                        const maxGB = ((vm.maxmem || 0) / 1024 ** 3).toFixed(1);\n                        final_message += `   • Memory: ${memGB}/${maxGB} GB • CPU: ${vm.cpus || '?'} cores\\n`;\n                    }\n                });\n            }\n        }\n        // FALLBACK\n        else {\n            final_message = `🔧 **${toolName.replace(/_/g, ' ').toUpperCase()}**\\n\\nNode: ${targetNode}\\n\\nData received successfully from MCP server.`;\n        }\n        \n        const result = {\n            json: {\n                final_message,\n                combinedMessage: final_message,\n                target_node: targetNode,\n                mcp_tools_used: mcpToolsUsed,\n                mcp_raw_response: aiAgentOutput.mcp_raw_response,\n                monitoring_results: monitoringResults,\n                details: { query_type: queryType, priority: 'normal', tool_name: toolName },\n                issue_detected: issueDetected,\n                applied_fix: appliedFix,\n                needs_approval: needsApproval,\n                commands_requested: needsApproval ? `${toolName} on ${targetNode}` : null,\n                branch: needsApproval ? \"send_and_wait\" : \"notify_user\",\n                subworkflow: \"proxmox_mcp\",\n                status_summary: final_message,\n                raw_response: aiAgentOutput\n            }\n        };\n        \n        console.log('Structure Output - Result:', JSON.stringify(result, null, 2));\n        return result;\n        \n    } catch (error) {\n        console.error('Structure Output - Error:', error);\n        return {\n            json: {\n                final_message: `❌ **Error:** ${error.message}`,\n                combinedMessage: `Error: ${error.message}`,\n                target_node: \"unknown\",\n                mcp_tools_used: [],\n                monitoring_results: {},\n                details: { query_type: \"error\", priority: \"high\", error: error.message },\n                issue_detected: true,\n                applied_fix: false,\n                needs_approval: false,\n                commands_requested: null,\n                branch: \"notify_user\",\n                subworkflow: \"error\",\n                status_summary: `Error: ${error.message}`,\n                raw_response: item.json\n            }\n        };\n    }\n});\n\nreturn results;\n"
      },
      "id": "682ede46-278b-4e71-b424-1f69ef8e2d49",
      "name": "Structure Output",
      "type": "n8n-nodes-base.code",
      "position": [
        2240,
        -1088
      ],
      "typeVersion": 2,
      "notes": "⚙️ **AI Response Processor**\n\n**Purpose:** Parse and standardize AI agent responses\n**Key Functions:**\n- Extract MCP tools used and monitoring results\n- Create comprehensive status summaries\n- Determine workflow branching (approval vs auto-execute)\n- Format data for downstream processing\n\n**Enhanced Features:**\n- Infrastructure status aggregation\n- Critical/warning/info classification\n- MCP tool tracking and result parsing"
    },
    {
      "parameters": {
        "jsCode": "try {\n  const userReply = ($json.content || $json.user_input || \"\").toLowerCase();\n  let approved = false;\n\n  if (userReply === \"approve\") {\n    approved = true;\n    $json.AIAgentOutput.needs_approval = false;\n  } else if (userReply === \"deny\") {\n    approved = false;\n    $json.AIAgentOutput.needs_approval = false;\n  } else {\n    // Invalid input\n    $json.AIAgentOutput.needs_approval = true;\n    $json.AIAgentOutput.applied_fix = false;\n    $json.AIAgentOutput.details = $json.AIAgentOutput.details || {};\n    $json.AIAgentOutput.details.invalid_input = $json.content || $json.user_input;\n    $json.AIAgentOutput.message = 'Approval input invalid or missing';\n  }\n\n  return [{\n    json: {\n      approval: approved,\n      target_node: $json.target_node,\n      url: $json.url,\n      response_type: $json.response_type,\n      details: $json.details,\n      node_auth: $json.node_auth,\n      combinedMessage: $json.combinedMessage,\n      needs_approval: $json.AIAgentOutput.needs_approval,\n      applied_fix: $json.AIAgentOutput.applied_fix,\n      message: $json.AIAgentOutput.message\n    }\n  }];\n} catch(err) {\n  $json.AIAgentOutput.issue_detected = true;\n  $json.AIAgentOutput.details = $json.AIAgentOutput.details || {};\n  $json.AIAgentOutput.details.error = err.message;\n\n  return [{\n    json: {\n      approval: false,\n      target_node: $json.target_node,\n      url: $json.url,\n      response_type: $json.response_type,\n      details: $json.details,\n      node_auth: $json.node_auth,\n      combinedMessage: $json.combinedMessage,\n      needs_approval: true,\n      applied_fix: false,\n      message: 'Error processing approval response'\n    }\n  }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3664,
        -1104
      ],
      "id": "6a7aac32-edfa-4503-a085-49223545292a",
      "name": "Parse Approval Response"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "cbfc5294-cec7-4ab9-a38c-4a8f5775681f",
              "leftValue": "={{ $json.approval }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3824,
        -1104
      ],
      "id": "49921547-4c02-4d6a-97a0-fa42f6537f3f",
      "name": "IS Approved"
    },
    {
      "parameters": {
        "channelId": "={{ $('Pull User Request').item.json.channelId }}",
        "content": "={{ \n  $items().map(item => {\n    const json = item.json;\n    let statusEmoji = \"⚪\";\n    let statusText = \"\";\n\n    if (json.needs_approval && json.approval === false) {\n      statusEmoji = \"🟡\"; statusText = \"Action declined by user\";\n    } else if (json.executed && json.response?.error) {\n      statusEmoji = \"🔴\"; statusText = `Error: ${json.response.error}`;\n    } else if (json.executed) {\n      statusEmoji = \"🟢\"; statusText = \"Action executed successfully\";\n    } else if (!json.executed && json.needs_approval) {\n      statusEmoji = \"🟠\"; statusText = \"Action skipped — awaiting approval\";\n    } else {\n      statusEmoji = \"🔵\"; statusText = \"Action not executed\";\n    }\n\n    return `${statusEmoji} Node: ${json.target_node}\\nAction: ${json.response_type} ${json.url}\\nStatus: ${statusText}\\n${json.combinedMessage || \"\"}`;\n  }).join(\"\\n----------------------------------------\\n\")\n}}\n",
        "botCustomization": true,
        "botActivity": "and Waiting...",
        "botActivityType": 3,
        "botStatus": "idle"
      },
      "type": "@jjuanrivvera99/n8n-nodes-discord.discord",
      "typeVersion": 1,
      "position": [
        4560,
        -1152
      ],
      "id": "59fdde9f-35d9-4f57-9656-1544cdfe5cf5",
      "name": "Send Followup",
      "credentials": {
        "discordApi": {
          "id": "zO7e3OjzgaUpNsfY",
          "name": "Discord App account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => {\n    const data = item.json;\n    const response = data.mcp_raw_response || data.data || {}; // USE MCP RAW RESPONSE\n    const subworkflow = $('When Executed by Another Workflow').first().json.SubWorkflow;\n    const structure = $('Structure Output').first().json || {};\n    \n    const needs_approval = structure.needs_approval;\n    const issue_detected = structure.issue_detected ?? false;\n    const applied_fix = structure.applied_fix ?? false;\n    const target_node = structure.target_node || \"unknown\";\n    const details = structure.details || {};\n    const queryType = details.query_type || details.query || \"generic\";\n    const monitoringResults = structure.monitoring_results || {};\n    const mcpToolsUsed = structure.mcp_tools_used || [];\n    const mcpRawResponse = structure.mcp_raw_response || {}; // ACCESS RAW MCP DATA\n\n    let message = \"\";\n    let summary = \"\";\n    \n    // === Declare common variables at function scope ===\n    const criticalIssues = monitoringResults.critical_issues || 0;\n    const warnings = monitoringResults.warnings || 0;\n\n    // === COMPREHENSIVE INFRASTRUCTURE STATUS ===\n    if (queryType === \"health_check\" || queryType === \"comprehensive_health_check\") {\n        const nodesOnline = monitoringResults.nodes_online || monitoringResults.nodes_checked?.length || 0;\n        const vmsRunning = monitoringResults.vms_running || 0;\n        const lxcsRunning = monitoringResults.lxcs_running || 0;\n        \n        summary = `🏗️ **Infrastructure Health Report**\\n`;\n        summary += `📊 **Overview:**\\n`;\n        summary += `- Nodes Online: ${nodesOnline} 🟢\\n`;\n        summary += `- VMs Running: ${vmsRunning} 💻\\n`;\n        summary += `- LXCs Running: ${lxcsRunning} 📦\\n`;\n        \n        // ADD DETAILED NODE INFORMATION FROM MCP RAW RESPONSE\n        if (mcpRawResponse.connectivity_test?.detailed_connectivity) {\n            summary += `\\n🖥️ **Node Details:**\\n`;\n            mcpRawResponse.connectivity_test.detailed_connectivity.forEach(node => {\n                const statusIcon = node.success ? '🟢' : '🔴';\n                summary += `${statusIcon} **${node.node_name}** (${node.type})\\n`;\n                summary += `   - Host: ${node.host}\\n`;\n                summary += `   - Version: ${node.version}\\n`;\n            });\n        }\n        \n        if (criticalIssues > 0) {\n            summary += `- Critical Issues: ${criticalIssues} 🔴\\n`;\n        }\n        if (warnings > 0) {\n            summary += `- Warnings: ${warnings} 🟡\\n`;\n        }\n        \n        if (mcpToolsUsed.length > 0) {\n            summary += `\\n🔧 **MCP Tools Used:** ${mcpToolsUsed.join(', ')}\\n`;\n        }\n        \n        if (monitoringResults.performance_summary) {\n            summary += `\\n📈 **Performance Summary:**\\n`;\n            Object.entries(monitoringResults.performance_summary).forEach(([key, value]) => {\n                summary += `- ${key}: ${value}\\n`;\n            });\n        }\n    }\n\n    // === AUTOMATED MAINTENANCE RESULTS ===\n    else if (queryType === \"automated_maintenance\") {\n        summary = `🔧 **Automated Maintenance Report**\\n`;\n        if (monitoringResults.issue) {\n            summary += `⚠️ **Issue Detected:** ${monitoringResults.issue}\\n`;\n        }\n        if (monitoringResults.fix_applied) {\n            summary += `✅ **Fix Applied:** ${monitoringResults.fix_applied}\\n`;\n        }\n        if (monitoringResults.status_after_fix) {\n            summary += `📊 **Status:** ${monitoringResults.status_after_fix}\\n`;\n        }\n    }\n\n    // === CRITICAL INCIDENT RESPONSE ===\n    else if (queryType === \"critical_incident\") {\n        summary = `🚨 **Critical Incident Report**\\n`;\n        if (monitoringResults.critical_error) {\n            summary += `❌ **Error:** ${monitoringResults.critical_error}\\n`;\n        }\n        if (monitoringResults.affected_vms) {\n            summary += `🖥️ **Affected VMs:** ${monitoringResults.affected_vms.join(', ')}\\n`;\n        }\n        if (monitoringResults.recommended_action) {\n            summary += `🛠️ **Recommended Action:** ${monitoringResults.recommended_action}\\n`;\n        }\n        if (details.estimated_downtime) {\n            summary += `⏱️ **Estimated Downtime:** ${details.estimated_downtime}\\n`;\n        }\n    }\n\n    // === VM LIST HANDLER (Legacy Support) ===\n    else if (Array.isArray(response) && response.some(vm => vm.vmid)) {\n        const vmSummaries = response.map(vm => {\n            const name = vm.name || `VM ${vm.vmid}`;\n            const statusIcon = vm.status === \"running\" ? \"🟢\" : \"🔴\";\n            const usedMemGB = (vm.mem / 1024 ** 3).toFixed(2);\n            const totalMemGB = (vm.maxmem / 1024 ** 3).toFixed(2);\n            const uptimeHours = (vm.uptime / 3600).toFixed(1);\n\n            return `${statusIcon} **${name}** (VMID: ${vm.vmid})\\n- Status: ${vm.status}\\n- CPU Cores: ${vm.cpus}\\n- Memory: ${usedMemGB} GB / ${totalMemGB} GB\\n- Uptime: ${uptimeHours} hours\\n- Tags: ${vm.tags || \"None\"}`;\n        }).join(\"\\n\\n\");\n\n        summary = `💻 **Virtual Machine Overview for ${target_node}**\\n\\n${vmSummaries}`;\n    }\n\n    // === STATUS SUMMARY FALLBACK ===\n    else if (structure.status_summary) {\n        summary = structure.status_summary;\n    }\n\n    // === Logic-based notification ===\n    if (!needs_approval) {\n        if (!issue_detected) {\n            if (criticalIssues === 0 && warnings === 0) {\n                message = `✅ **All Systems Operational**\\n${summary}`;\n            } else {\n                message = `ℹ️ **Status Update**\\n${summary}`;\n            }\n        } else if (applied_fix) {\n            message = `🛠️ **Issue Auto-Resolved**\\n${summary}`;\n        } else {\n            message = `⚠️ **Issue Detected**\\n${summary}`;\n        }\n    } else {\n        const priority = details.priority === \"critical\" ? \"🚨\" : \"⚠️\";\n        message = `${priority} **Action Requires Approval**\\n${summary}`;\n    }\n\n    // === Return structured output for parent workflow ===\n    return {\n        json: {\n            ...data,\n            subworkflow,\n            summary,\n            final_message: message,\n            raw_response: response,\n            mcp_raw_response: mcpRawResponse, // INCLUDE MCP RAW DATA\n            metadata: {\n                query_type: queryType,\n                needs_approval,\n                issue_detected,\n                applied_fix,\n                target_node,\n                subworkflow,\n                monitoring_results: monitoringResults,\n                mcp_tools_used: mcpToolsUsed,\n                mcp_raw_response: mcpRawResponse // ALSO IN METADATA\n            }\n        }\n    };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3120,
        -912
      ],
      "id": "81dc219f-cfde-4116-8f09-e8d83fd9eb0c",
      "name": "Notify User",
      "notes": "📊 **Enhanced Status Reporter**\n\n**Purpose:** Generate comprehensive infrastructure status reports\n**Report Types:**\n- 🏗️ Infrastructure Health Reports\n- 🔧 Automated Maintenance Results  \n- 🚨 Critical Incident Responses\n- 💻 VM/LXC Overview (legacy support)\n\n**Enhanced Features:**\n- Smart formatting based on query type\n- MCP tools usage tracking\n- Performance metrics integration\n- Priority-based messaging (critical/warning/info)"
    },
    {
      "parameters": {
        "type": "none",
        "botCustomization": true,
        "botActivity": "Request, Standby...",
        "botActivityType": 1
      },
      "type": "@jjuanrivvera99/n8n-nodes-discord.discord",
      "typeVersion": 1,
      "position": [
        1536,
        -1088
      ],
      "id": "953d0b6a-0d44-47e8-838f-2b96933f8a4b",
      "name": "Processing Request",
      "credentials": {
        "discordApi": {
          "id": "zO7e3OjzgaUpNsfY",
          "name": "Discord App account"
        }
      }
    },
    {
      "parameters": {
        "fieldsToAggregate": {
          "fieldToAggregate": [
            {}
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        4400,
        -1152
      ],
      "id": "af58ce66-00d1-4ab2-a0b2-3105ce7e9d41",
      "name": "Aggregate"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "6fc385e5-d514-4a79-9de2-64a0ec3603e7",
              "leftValue": "branch",
              "rightValue": "send_and_wait",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2704,
        -1088
      ],
      "id": "2f900ea0-89e0-45cd-9d99-7bdeb1a5a948",
      "name": "Needs Approval"
    },
    {
      "parameters": {
        "jsCode": "// Handle approved MCP actions execution results\nconst results = [];\nlet humanReadableSummary = \"\";\n\nfor (const item of $items()) {\n    const {\n        target_node,\n        needs_approval,\n        approval,\n        combinedMessage,\n        commands_requested,\n        mcp_tools_used,\n        monitoring_results\n    } = item.json;\n\n    let executed = false;\n    let response = null;\n    let actionTaken = false;\n\n    // Determine if we should execute:\n    const canExecute = !needs_approval || (needs_approval && approval === true);\n\n    if (canExecute) {\n        // Execute through MCP Server\n        response = {\n            success: true,\n            action: commands_requested || \"Health check completed\",\n            target_node: target_node,\n            tools_used: mcp_tools_used || [],\n            monitoring_results: monitoring_results || {},\n            execution_time: new Date().toISOString(),\n            message: \"Action executed successfully via MCP Server\"\n        };\n        executed = true;\n        actionTaken = true;\n    } else {\n        response = { skipped: true, reason: \"Approval required or denied\" };\n    }\n\n    // Construct human-readable summary per item\n    const actionDesc = commands_requested || \"Monitoring check\";\n    humanReadableSummary += `\\nNode: ${target_node}\\nAction: ${actionDesc}\\nStatus: ${executed ? \"✅ Executed via MCP\" : \"❌ Skipped\"}\\n`;\n    \n    if (response.error) {\n        humanReadableSummary += `Error: ${response.error}\\n`;\n    } else if (response.skipped) {\n        humanReadableSummary += `Reason: ${response.reason}\\n`;\n    } else if (executed && response.tools_used) {\n        humanReadableSummary += `MCP Tools: ${response.tools_used.join(', ')}\\n`;\n    }\n    \n    humanReadableSummary += \"----------------------------------------\";\n\n    results.push({\n        json: {\n            ...item.json,\n            executed,\n            response,\n            actionTaken,\n            humanReadableSummary\n        }\n    });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4208,
        -1232
      ],
      "id": "d98af351-2c56-4bee-ab9a-b492e9a1f6e4",
      "name": "Approved Followup"
    },
    {
      "parameters": {
        "jsCode": "// Handle declined MCP actions\nconst results = [];\nlet humanReadableSummary = \"\";\n\nfor (const item of $items()) {\n    const {\n        target_node,\n        needs_approval,\n        approval,\n        combinedMessage,\n        commands_requested,\n        mcp_tools_used\n    } = item.json;\n\n    // Only process items that required approval but were declined\n    if (needs_approval && approval === false) {\n        const actionDesc = commands_requested || \"Monitoring action\";\n        humanReadableSummary += `\\nNode: ${target_node}\\nAction: ${actionDesc}\\nStatus: ❌ Declined by user\\n`;\n        humanReadableSummary += `MCP Tools: ${(mcp_tools_used || []).join(', ')}\\n`;\n        humanReadableSummary += `Message: ${combinedMessage}\\n----------------------------------------`;\n\n        results.push({\n            json: {\n                ...item.json,\n                executed: false,\n                response: { \n                    skipped: true, \n                    reason: \"Declined by user\",\n                    action_requested: commands_requested,\n                    mcp_tools_planned: mcp_tools_used\n                },\n                actionTaken: false,\n                humanReadableSummary\n            }\n        });\n    } else {\n        // Pass through items that don't match this branch\n        results.push({ json: { ...item.json } });\n    }\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4208,
        -1088
      ],
      "id": "9c47f192-8aee-44f3-8fe6-afc8c4012628",
      "name": "Declined Followup"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "include": "specifiedFields",
        "fieldsToInclude": "=",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        4864,
        -912
      ],
      "id": "b52e62d6-686e-4f0a-bb73-204a7adc8d15",
      "name": "Task Complete"
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "content"
            },
            {
              "name": "SubWorkflow",
              "type": "boolean"
            },
            {
              "name": "channelId"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        1216,
        -1088
      ],
      "id": "4b798516-73d6-4e7b-bb53-5c8c186d7f7b",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "jsCode": "try {\n    // Safely grab JSON input\n    const inputData = $input.first().json || {};\n    const data = $json || {};\n\n    // Pull known structured fields\n    const metadata = inputData.metadata || {};\n    const response = inputData.raw_response || inputData.data || {};\n    const needs_approval = metadata.needs_approval ?? false;\n    const target_node = metadata.target_node || \"unknown\";\n    const queryType = metadata.query || \"generic\";\n\n    let final_message = $('Notify User').first().json.final_message || \"\";\n    let summary = $('Notify User').first().json.combinedMessage || \"\";\n\n    // === Detect if this is a VM list ===\n    if (Array.isArray(response) && response.some(vm => vm.vmid)) {\n        const vmSummaries = response.map(vm => {\n            const name = vm.name || `VM ${vm.vmid}`;\n            const statusIcon = vm.status === \"running\" ? \"🟢\" : \"🔴\";\n            const usedMemGB = vm.mem ? (vm.mem / 1024 ** 3).toFixed(2) : \"0.00\";\n            const totalMemGB = vm.maxmem ? (vm.maxmem / 1024 ** 3).toFixed(2) : \"0.00\";\n            const uptimeHours = vm.uptime ? (vm.uptime / 3600).toFixed(1) : \"0\";\n\n            return `${statusIcon} **${name}** (VMID: ${vm.vmid})\n- Status: ${vm.status}\n- CPU Cores: ${vm.cpus ?? \"?\"}\n- Memory: ${usedMemGB} GB / ${totalMemGB} GB\n- Uptime: ${uptimeHours} hours\n- Tags: ${vm.tags || \"None\"}  \n`;\n        }).join(\"\\n\");\n\n        summary = `💻 **Virtual Machine Overview for ${target_node}**\\n\\n${vmSummaries}`;\n        final_message = summary; // override with VM summary if present\n    }\n\n    // === If it’s not VM data but has an existing message ===\n    else if (!final_message && inputData.summary) {\n        final_message = inputData.summary;\n    }\n\n    // === Determine branch ===\n    const branch = needs_approval ? 'send_and_wait' : 'notify_user';\n\n    // === Return unified JSON ===\n    return [{\n        json: {\n            final_message,\n            summary,\n            target_node,\n            queryType,\n            needs_approval,\n            branch\n        }\n    }];\n} catch (err) {\n    return [{\n        json: {\n            summary: `❌ Error in Notify Task Complete IF SubWorkflow: ${err.message}`,\n            target_node: 'unknown',\n            branch: 'notify_user',\n            issue_detected: true,\n            applied_fix: false,\n            needs_approval: false\n        }\n    }];\n}\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5040,
        -912
      ],
      "id": "a277b339-c3f5-46b1-a044-603fbdaffde6",
      "name": "Notify Task Complete IF SubWorkflow"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "6ccd6220-95e5-4352-ab64-8b029f37652d",
              "name": "content",
              "value": "={{ $json.content }}",
              "type": "string"
            },
            {
              "id": "channelId",
              "name": "channelId",
              "value": "={{ $json.channelId }}",
              "type": "string"
            },
            {
              "id": "subworkflow",
              "name": "subworkflow",
              "value": "={{ $json.SubWorkflow }}",
              "type": "boolean"
            }
          ]
        },
        "options": {}
      },
      "id": "9723ebb3-b2f4-433c-9ed1-d789c2407271",
      "name": "Pull User Request",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1376,
        -1088
      ]
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2016,
        112
      ],
      "id": "16576fce-b9fc-4bd6-b49e-cb8ae8225b29",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "options": {
          "prompt": "Instructions:\n--------------\n{instructions}\n--------------\nCompletion:\n--------------\n{completion}\n--------------\n\nAbove, the Completion did not satisfy the constraints given in the Instructions.\nError:\n--------------\n{error}\n--------------\n\nPlease try again. Please only respond with an answer that satisfies the constraints laid out in the Instructions:"
        }
      },
      "id": "a7171a61-3cd2-4b76-bd11-2004a7139615",
      "name": "Auto-fixing Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserAutofixing",
      "position": [
        1968,
        -176
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "model": "llama3.2:3b",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmOllama",
      "typeVersion": 1,
      "position": [
        1968,
        -16
      ],
      "id": "c47e1097-e94f-436f-9e79-04bd7b49f8f8",
      "name": "Tool Model",
      "credentials": {
        "ollamaApi": {
          "id": "g4qsIa9ik5l18myY",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process completed MCP tool execution results from AI Agent\nconst results = [];\n\nfor (const item of $items()) {\n    const data = item.json;\n    const mcpToolsUsed = data.mcp_tools_used || [];\n    const monitoringResults = data.monitoring_results || {};\n    const targetNode = data.target_node || 'unknown';\n    const message = data.final_message || data.combinedMessage || '';\n    \n    // The AI Agent has already executed MCP tools through the MCP CLIENT\n    // We just need to format the response for the notification system\n    const mcpResponse = {\n        success: true,\n        tools_executed: mcpToolsUsed,\n        results: monitoringResults,\n        target_node: targetNode,\n        message: message,\n        timestamp: new Date().toISOString(),\n        execution_method: \"ai_agent_mcp_client\"\n    };\n    \n    console.log(`MCP Tools Execution - Processing ${mcpToolsUsed.join(', ')} for ${targetNode}`);\n    \n    results.push({\n        json: {\n            ...data,\n            data: mcpResponse,\n            mcp_execution_completed: true,\n            executed: true,\n            response: mcpResponse,\n            actionTaken: true\n        }\n    });\n}\n\nreturn results;\n"
      },
      "id": "aae8c5d7-4e1a-4463-9ef5-1ee1037ef8ad",
      "name": "MCP Tools Execution",
      "type": "n8n-nodes-base.code",
      "position": [
        2928,
        -976
      ],
      "typeVersion": 2,
      "notes": "🔧 **MCP Server Integration Point**\n\n**Purpose:** Execute safe monitoring and automated fixes via MCP\n**Input:** AI-determined MCP tools and monitoring requirements\n**Output:** Structured results from MCP Server execution\n\n**Operations:**\n- Health checks and status monitoring\n- Automated log rotation and cleanup\n- Service restart (if safe)\n- Performance data collection\n\n**Note:** In production, this connects to actual MCP Server tools"
    },
    {
      "parameters": {
        "jsCode": "// Execute approved actions through MCP tools\nconst results = [];\n\nfor (const item of $items()) {\n    const data = item.json;\n    const target_node = data.target_node;\n    const commands_requested = data.commands_requested;\n    const mcp_tools_used = data.mcp_tools_used || [];\n    \n    // Execute approved action through MCP\n    const mcpResponse = {\n        success: true,\n        action_executed: commands_requested,\n        target_node: target_node,\n        tools_used: mcp_tools_used,\n        execution_time: new Date().toISOString(),\n        status: \"Action completed successfully through MCP Server\"\n    };\n    \n    results.push({\n        json: {\n            ...data,\n            data: mcpResponse,\n            executed: true,\n            response: mcpResponse,\n            actionTaken: true\n        }\n    });\n}\n\nreturn results;\n"
      },
      "id": "6d75af6a-c007-478a-b021-03b17b3569b5",
      "name": "MCP Approved Action Execution",
      "type": "n8n-nodes-base.code",
      "position": [
        4032,
        -1232
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "toolDescription": "Get the proxmox API details from Proxmox Wiki",
        "url": "https://pve.proxmox.com/wiki/Proxmox_VE_API"
      },
      "id": "5a52fb1f-1ed5-4d81-a6e1-d8730677ba20",
      "name": "PVE API Wiki",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "position": [
        2000,
        -512
      ],
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "toolDescription": "This is Proxmox API Documentation ensure to read the details from here",
        "url": "https://pve.proxmox.com/pve-docs/api-viewer/index.html"
      },
      "id": "6d39f9bf-da1b-405a-aa86-d40e3a00a2e2",
      "name": "PVE API Docs",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "position": [
        2000,
        -688
      ],
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "toolDescription": "This is Proxmox API Documentation ensure to read the details from here",
        "url": "https://pbs.proxmox.com/docs/api-viewer/index.html#"
      },
      "id": "2d6c341a-fe6b-4208-a86d-5a5fe411751b",
      "name": "PBS API Docs",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "position": [
        2000,
        -352
      ],
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "content": "## 🏗️ Proxmox MCP Agent Workflow - Enhanced\n\n### 📋 **Workflow Overview**\nThis workflow provides comprehensive Proxmox infrastructure monitoring and management through MCP Server integration.\n\n### 🔄 **Flow Path:**\n1. **Input** → User request from Discord ChatBot\n2. **AI Analysis** → Proxmox Agent analyzes request\n3. **MCP Integration** → Uses MCP tools for operations\n4. **Decision Logic** → Auto-fix safe issues, request approval for dangerous ones\n5. **Execution** → Perform approved actions via MCP\n6. **Response** → Send detailed status back to Discord\n\n### 🎯 **Key Features:**\n- ✅ Comprehensive monitoring (ALL nodes, VMs, LXCs, PBS)\n- 🤖 Automated troubleshooting with safety controls\n- 👤 User approval workflow for disruptive actions\n- 📊 Detailed status reporting and alerts\n- 🔧 MCP Server integration for all Proxmox operations",
        "height": 503,
        "width": 605,
        "color": 4
      },
      "id": "93edf00f-0bbf-4b8c-be83-ef1bbf4b7029",
      "name": "Workflow Overview",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        512,
        -1760
      ]
    },
    {
      "parameters": {
        "content": "## 🚀 **Input Stage**\n\n### **Trigger:** When Executed by Another Workflow\n- Receives requests from Discord ChatBot\n- Extracts user content and channel info\n- Supports SubWorkflow mode for integration\n\n### **Pull User Request**\n- Standardizes input format\n- Prepares data for AI processing\n\n### **Processing Request** \n- Updates Discord bot status\n- Shows \"Request, Standby...\" activity",
        "height": 2008,
        "width": 520,
        "color": 5
      },
      "id": "14276a5b-5a0f-4c1d-acdd-4c4425a1289d",
      "name": "Input Stage",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1168,
        -1760
      ]
    },
    {
      "parameters": {
        "content": "## 🧠 **AI Analysis Stage - Enhanced MCP Integration**\n\n### **Proxmox Agent (AI)**\n- **MCP Server Integration:** Connected to mcp_server_http.py (localhost:8000)\n- **Real-time Tool Access:** Direct MCP CLIENT connection\n- **Enhanced System Prompt:** Mandatory MCP tool usage protocol\n- **Available Tools:**\n  - 🖥️ get_node_status: PVE/PBS health monitoring\n  - 💻 get_vm_list: VM/LXC inventory management\n  - 🔍 get_vm_status: Detailed VM performance metrics\n  - ⚡ start_vm/stop_vm: VM control (approval required)\n  - � send_notification: Alert management\n\n### **Response Processing**\n- **Structured Output Parser:** JSON schema validation\n- **Auto-fixing Parser:** Error correction and retry\n- **Enhanced Structure Output:** Processes actual MCP responses\n- **Real Data Only:** No synthetic or placeholder responses",
        "height": 2012,
        "width": 740,
        "color": 6
      },
      "id": "eedf3833-e473-47e1-bbf3-ac9cc7b83fae",
      "name": "AI Analysis Stage",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        1712,
        -1760
      ]
    },
    {
      "parameters": {
        "content": "## ⚡ **Decision & Execution Stage**\n\n### **Structure Output**\n- Parses AI response into standardized format\n- Extracts MCP tools used, monitoring results\n- Creates comprehensive status summaries\n- Determines approval requirements\n\n### **Needs Approval** (IF Node)\n- **Path 1:** Requires Approval → Send AND Wait\n- **Path 2:** Safe Operations → MCP Tools Execution\n\n### **MCP Tools Execution**\n- Executes monitoring and safe operations via MCP\n- Returns structured results from MCP Server\n- Handles automated troubleshooting\n\n### **Approval Workflow**\n- **Send AND Wait:** Discord approval request with detailed info\n- **Parse Approval Response:** Processes approve/deny\n- **IS Approved:** Routes based on user decision",
        "height": 2004,
        "width": 748,
        "color": 7
      },
      "id": "ac1c9e04-63c1-4bf9-ab17-d7561d38d528",
      "name": "Decision & Execution Stage",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        2480,
        -1760
      ]
    },
    {
      "parameters": {
        "content": "## 📤 **Response & Completion Stage**\n\n### **Notify User**\n- **Enhanced Status Reports:** Infrastructure health, maintenance results, critical incidents\n- **Smart Formatting:** Different templates based on query type\n- **Comprehensive Details:** Nodes, VMs, LXCs, performance metrics\n\n### **Approval Action Paths:**\n- **MCP Approved Action Execution:** Executes approved dangerous operations\n- **Approved Followup:** Processes successful executions\n- **Declined Followup:** Handles user-declined actions\n\n### **Final Response:**\n- **Aggregate:** Combines all execution results\n- **Send Followup:** Detailed execution status to Discord\n- **Send Reply:** Main response with comprehensive status\n- **Task Complete:** Workflow completion\n\n### **SubWorkflow Support:**\n- **Notify Task Complete IF SubWorkflow:** Handles parent workflow integration",
        "height": 2004,
        "width": 1968,
        "color": 3
      },
      "id": "845d9374-b47f-4a35-96ba-ebbf25792d5f",
      "name": "Response & Completion Stage",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3264,
        -1760
      ]
    },
    {
      "parameters": {
        "content": "## 🔄 **Complete Workflow Logic**\n\n### **Example Flow 1: Health Check Request**\n1. **Discord User:** \"@bot check proxmox status\"\n2. **Discord ChatBot** → Routes to this workflow\n3. **AI Agent** → Analyzes: \"comprehensive_health_check\" required\n4. **MCP Tools** → get_cluster_status, check_node_health, monitor_vms\n5. **Result:** ✅ All systems operational - 3 nodes, 15 VMs, 8 LXCs running\n6. **Discord Response:** Comprehensive infrastructure report\n\n### **Example Flow 2: Critical Issue (Requires Approval)**\n1. **AI Detects:** Node pve2 kernel panic, VMs affected\n2. **Recommendation:** Emergency reboot required\n3. **Discord Approval:** Shows impact, affected VMs, estimated downtime\n4. **User Decision:** approve/deny\n5. **If Approved:** MCP executes reboot via approved action path\n6. **Result:** Detailed execution status and recovery confirmation\n\n### **Example Flow 3: Auto-Fix Applied**\n1. **AI Detects:** High disk usage on /var/log (>90%)\n2. **Auto-Fix:** Log rotation, freed 2.3GB space\n3. **Result:** Issue resolved automatically, normal operation resumed\n4. **Discord:** Maintenance report with before/after status\n\n### **Key Safety Features:**\n- 🛡️ **Safe Operations:** Auto-executed (monitoring, log rotation, service restarts)\n- ⚠️ **Dangerous Operations:** Always require user approval\n- 📊 **Comprehensive Monitoring:** ALL infrastructure components tracked\n- 🔧 **MCP Integration:** Centralized Proxmox operations through MCP Server",
        "height": 744,
        "width": 612,
        "color": 2
      },
      "id": "9ec7b9fd-1b46-43dd-9551-04dd32a22dce",
      "name": "Complete Workflow Documentation",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        512,
        -1248
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('Pull User Request').item.json.content }}",
        "options": {
          "systemMessage": "=# Proxmox AI Agent - System Message\n\nYou are a Proxmox infrastructure AI assistant with MCP tool access.\n\nYour job is to:\n\n1. Understand the user's request\n2. Call the appropriate MCP tool(s)\n3. Return the tool results with minimal metadata\n\nIMPORTANT: Do NOT format the data for humans. Just pass through the MCP tool results.\n\nYour response MUST be valid JSON, do not output malformed JSON:\n\n{\"tool_name\": \"<name of MCP tool used>\",\"target_node\": \"<node name or 'all'>\",\"mcp_tools_used\": [\"<tool1>\", \"<tool2>\"],\"mcp_raw_response\": <COMPLETE UNMODIFIED TOOL RESPONSE>,\"needs_approval\": false,\"issue_detected\": false,\"applied_fix\": false}\n\nExample JSON Tool Data:\n{\"Tool\":{\"response\": [{\"type\": \"text\",\"text\": {\"PVE-Test1\": {\"type\": \"PVE\",\"host\": \"192.168.1.1\",\"status\": \"online\",\"port\": 8006},\n\"PVE-Test2\": {\"type\": \"PVE\",\"host\": \"192.168.1.2\",\"status\": \"online\",\"port\": 8006},\"PVE-Test3\": {\"type\": \"PVE\",\"host\": \"192.168.1.3\",\"status\": \"online\",\"port\": 8006},\"PBS-PBS\": {\"type\": \"PBS-Test1\",\"host\": \"192.168.1.4\",\"status\": \"online\",\"port\": 8007}}}]},\"needs_approval\": false,\"issue_detected\": false,\"applied_fix\": false}\n**You MUST only output that JSON data!**\n\n## Available MCP Tools\n\n### 1. get_node_status\n\n**Purpose:** Get status of all Proxmox nodes (PVE and PBS)\n\n**Parameters:**\n\n- `node_type` (optional): Type of nodes to query\n  - Options: \"pve\", \"pbs\", \"all\"\n  - Default: \"all\"\n\n**Example User Queries:**\n\n- \"What is the status of my Proxmox nodes?\"\n- \"Are all my servers online?\"\n- \"Check node health\"\n- \"Show me PVE node status\"\n- \"What's the status of my backup servers?\"\n\n**When to Use:**\n\n- User asks about node health/status\n- User wants to check if nodes are online/offline\n- User wants to see infrastructure overview\n- User asks about PVE or PBS nodes specifically\n\n**ONLY RETURN JSON RESPONSE PROPPERLY FORMATTED! DO NOT ELABORATE OR ADD FURTHER DATA! ONLY RETURN THE JSON RESPONSE!**\n\n---\n\n### 2. get_vm_list\n\n**Purpose:** Get list of VMs/containers from Proxmox nodes\n\n**Parameters:**\n\n- `node_name` (optional): Specific node name to query\n- `vm_type` (optional): Type of VMs to list\n  - Options: \"qemu\", \"lxc\", \"all\"\n  - Default: \"all\"\n\n**Example User Queries:**\n\n- \"How many VMs are running?\"\n- \"List all VMs on node pve-01\"\n- \"Show me all containers\"\n- \"What VMs are on my Proxmox server?\"\n- \"List all QEMU virtual machines\"\n\n**When to Use:**\n\n- User asks about VMs or containers\n- User wants to see what's running on a specific node\n- User asks for VM count or list\n- User wants to filter by VM type (QEMU vs LXC)\n\n---\n\n### 3. get_vm_status\n\n**Purpose:** Get detailed status of a specific VM/container\n\n**Parameters:**\n\n- `node_name` (required): Name of the Proxmox node\n- `vmid` (required): VM/Container ID\n\n**Example User Queries:**\n\n- \"What's the status of VM 100?\"\n- \"Check VM 203 on pve-01\"\n- \"Is container 105 running?\"\n- \"Show me details for VMID 301\"\n\n**When to Use:**\n\n- User asks about a specific VM/container by ID\n- User wants detailed information about one VM\n- User mentions both node name and VM ID\n- User asks \"is VM X running/online/active\"\n\n---\n\n### 4. start_vm\n\n**Purpose:** Start a VM/container\n\n**Parameters:**\n\n- `node_name` (required): Name of the Proxmox node\n- `vmid` (required): VM/Container ID\n\n**Example User Queries:**\n\n- \"Start VM 100\"\n- \"Turn on container 205\"\n- \"Boot up VM 301 on pve-01\"\n- \"Can you start VMID 150?\"\n\n**When to Use:**\n\n- User explicitly asks to start/boot/turn on a VM\n- User wants to power on a specific VM\n- User mentions \"start\", \"boot\", \"turn on\", \"power on\"\n\n**IMPORTANT:** This is a state-changing operation. Set `needs_approval: true` in response.\n\n---\n\n### 5. stop_vm\n\n**Purpose:** Stop a VM/container\n\n**Parameters:**\n\n- `node_name` (required): Name of the Proxmox node\n- `vmid` (required): VM/Container ID\n\n**Example User Queries:**\n\n- \"Stop VM 100\"\n- \"Shut down container 205\"\n- \"Turn off VM 301 on pve-01\"\n- \"Can you stop VMID 150?\"\n\n**When to Use:**\n\n- User explicitly asks to stop/shutdown/turn off a VM\n- User wants to power off a specific VM\n- User mentions \"stop\", \"shutdown\", \"turn off\", \"power off\"\n\n**IMPORTANT:** This is a state-changing operation. Set `needs_approval: true` in response.\n\n---\n\n### 6. send_notification\n\n**Purpose:** Send notification via configured channels (Discord, Gotify)\n\n**Parameters:**\n\n- `title` (required): Notification title\n- `message` (required): Notification message\n- `priority` (optional): Notification priority\n  - Options: \"low\", \"normal\", \"high\", \"critical\"\n  - Default: \"normal\"\n\n**Example User Queries:**\n\n- \"Send me a notification when done\"\n- \"Alert me about this issue\"\n- \"Notify the team about this problem\"\n- \"Send a high priority alert\"\n\n**When to Use:**\n\n- User explicitly asks to send notification/alert\n- User wants to be notified about something\n- Use after completing important operations\n- Use for critical issues or errors\n\n---\n\n## Tool Selection Strategy\n\n1. **Node Health Queries** → use `get_node_status`\n2. **VM/Container Lists** → use `get_vm_list`\n3. **Specific VM Info** → use `get_vm_status`\n4. **Power On VM** → use `start_vm` (set needs_approval=true)\n5. **Power Off VM** → use `stop_vm` (set needs_approval=true)\n6. **Send Alerts** → use `send_notification`\n\n## Response Format Rules\n\nAlways include the COMPLETE `mcp_raw_response` without modifications.\n\nFor **read-only operations** (get_node_status, get_vm_list, get_vm_status):\n\n- `needs_approval`: false\n- `issue_detected`: false\n- `applied_fix`: false\n\nFor **state-changing operations** (start_vm, stop_vm):\n\n- `needs_approval`: true\n- `issue_detected`: false (unless error detected)\n- `applied_fix`: false (true only if you actually executed the change)\n\nFor **notifications**:\n\n- `needs_approval`: false\n- Set appropriate priority based on context\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1904,
        -1088
      ],
      "id": "65cd0ac6-a922-47c7-a8b2-f79cb3cc52ef",
      "name": "AI Agent",
      "alwaysOutputData": true,
      "retryOnFail": true
    },
    {
      "parameters": {
        "model": "llama3.2:3b",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [
        1760,
        -880
      ],
      "id": "6348e117-b535-48ba-9b6a-1689537d89e5",
      "name": "Ollama Chat Model",
      "credentials": {
        "ollamaApi": {
          "id": "g4qsIa9ik5l18myY",
          "name": "Ollama account"
        }
      }
    }
  ],
  "connections": {
    "MCP Tool": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Send AND Wait": {
      "main": [
        [
          {
            "node": "Parse Approval Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structure Output": {
      "main": [
        [
          {
            "node": "Needs Approval",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Approval Response": {
      "main": [
        [
          {
            "node": "IS Approved",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IS Approved": {
      "main": [
        [
          {
            "node": "MCP Approved Action Execution",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Declined Followup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Followup": {
      "main": [
        [
          {
            "node": "Task Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Notify User": {
      "main": [
        [
          {
            "node": "Task Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Processing Request": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate": {
      "main": [
        [
          {
            "node": "Send Followup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Approval": {
      "main": [
        [
          {
            "node": "Send AND Wait",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "MCP Tools Execution",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Approved Followup": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Declined Followup": {
      "main": [
        [
          {
            "node": "Aggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Task Complete": {
      "main": [
        [
          {
            "node": "Notify Task Complete IF SubWorkflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Pull User Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pull User Request": {
      "main": [
        [
          {
            "node": "Processing Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Auto-fixing Output Parser",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Tool Model": {
      "ai_languageModel": [
        [
          {
            "node": "Auto-fixing Output Parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "MCP Tools Execution": {
      "main": [
        [
          {
            "node": "Notify User",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MCP Approved Action Execution": {
      "main": [
        [
          {
            "node": "Approved Followup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PVE API Wiki": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "PVE API Docs": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "PBS API Docs": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Structure Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "74f7b7e43879ad5e066683ec12b69cba1be8c55b373082f88b61cf23c5b39233"
  }
}